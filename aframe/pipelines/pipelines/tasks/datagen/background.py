import os

import luigi
import numpy as np
from luigi.util import inherits
from pipelines.tasks.apptainer import CondorApptainerTask
from pipelines.tasks.datagen.segments import GenerateSegments


def _intify(x: float):
    """
    Converts the input float into an int if the two are equal (e.g., 4.0 == 4).
    Otherwise, returns the input unchanged.
    """
    return int(x) if int(x) == x else x


def _make_fname(prefix, t0, length):
    """Creates a filename for background files in a consistent format"""
    t0 = _intify(t0)
    length = _intify(length)
    return f"{prefix}-{t0}-{length}.hdf5"


# LaunchGenerateBackground now "inherits" all parameters from GenerateSegments
# see https://luigi.readthedocs.io/en/stable/api/luigi.util.html
@inherits(GenerateSegments)
class SubmitGenerateBackground(CondorApptainerTask):
    output_dir = luigi.Parameter()
    sample_rate = luigi.FloatParameter()
    channel = luigi.Parameter()
    segments = luigi.ListParameter()

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.segment_file = os.path.join(self.output_dir, "segments.txt")

    @property
    def name(self):
        return "generate_background"

    @property
    def queue(self):
        return (
            f"queue start,stop,writepath from {self.submit_dir}/parameters.txt"
        )

    def output(self):
        # output is a list of LocalTargets, one for each segment
        # generated by downstream GenerateSegments task.
        # If we an't full "atomicity" like Luigi suggests, we could make
        # each segment an individual condor submission,
        # but for now this is probably fine
        starts = self.segments[:, 0]
        durations = self.segments[:, 1] - self.starts
        return [
            luigi.LocalTarget(
                os.path.join(
                    self.output_dir, _make_fname("background", start, duration)
                )
            )
            for start, duration in zip(starts, durations)
        ]

    @property
    def command(self):
        command = f"""
            python /opt/aframe/aframe/datagen/datagen/background.py
                --start $(start)
                --stop $(stop)
                --channel {self.channel}
                --ifos {' '.join(self.ifos)}
                --sample-rate {self.sample_rate}
                --write-path $(writepath)
        """
        return command

    @property
    def image(self) -> str:
        default = os.path.expanduser("~/aframe/images")
        root = os.environ.get("AFRAME_CONTAINER_ROOT", default)
        return os.path.join(root, "datagen.sif")


# This is apparently a common patter in Luigi for
# dynamic requirements (
# e.g. the paths of the output background files depend on the queried segments)
# Have a "wrapper" task that requires the dynamic depdency.
# Then in the run method, parse the dependency and pass to downstream task
@inherits(SubmitGenerateBackground)
class GenerateBackground(luigi.Task):
    output_dir = luigi.Parameter()

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.segment_file = os.path.join(self.output_dir, "segments.txt")

    @property
    def segments(self):
        return np.loadtxt(self.input().open("r"))

    def requires(self):
        # clone will pass common parameters to GenerateSegments.
        # need to explicitly pass constructed output_file
        # since this is not a common parameter
        return self.clone(GenerateSegments, output_file=self.segment_file)

    def write_parameters(self, segments: np.ndarray):
        with open(self.submit_dir / "parameters.txt", "w") as f:
            f.write("start,stop,writepath\n")
            for start, stop, writepath in segments:
                f.write(f"{start},{stop},{writepath}\n")

    def validate_segments(
        self,
    ):
        # determine which segments need to be generated
        generate = []
        for start, stop in self.segments:
            duration = stop - start
            fname = _make_fname("background", start, duration)
            write_path = self.output_dir / fname

            if not write_path.exists():
                generate.append([start, stop, write_path])

        return generate

    def run(self):
        # validate segments and write parameters to file
        segments = self.validate_segments()
        self.write_parameters(segments)

        # launch apptainer condor job
        # clone will pass common parameters to LaunchGenerateBackground
        yield self.clone(SubmitGenerateBackground, segments=segments)
